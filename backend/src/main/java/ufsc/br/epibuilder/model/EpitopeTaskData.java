package ufsc.br.epibuilder.model;

import java.io.File;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import jakarta.persistence.Transient;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

/**
 * Represents a single epitope prediction task containing all configuration
 * parameters
 * and results. This entity serves as the parent container for generated
 * epitopes.
 */
@Entity
@Table(name = "epitope_task_data")
@Getter
@Setter
@ToString
public class EpitopeTaskData {

    /**
     * Unique identifier for the task
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Timestamp when the task was executed
     */
    @Column(name = "execution_date")
    private LocalDateTime executionDate;

    /**
     * Timestamp when the task was finished
     */
    @Column(name = "finished_date")
    private LocalDateTime finishedDate;

    /**
     * User who created this task (LAZY-loaded for performance)
     */
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", nullable = false)
    @JsonBackReference
    private User user;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "task_status_id", referencedColumnName = "id")
    @JsonManagedReference
    private TaskStatus taskStatus;

    /**
     * List of epitopes generated by this task
     * Cascades all operations and removes orphaned epitopes
     */
    @OneToMany(mappedBy = "epitopeTaskData", fetch = FetchType.EAGER, cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonManagedReference
    private List<Epitope> epitopes = new ArrayList<>();

    /**
     * Identifier for this specific run
     */
    @Column(nullable = false)
    private String runName;

    /**
     * FASTA file containing protein sequence(s) for analysis
     * Marked as Transient as it's not persisted in the database
     */
    @Transient
    private File file;

    @Column(nullable = false)
    private String absolutePath;

    @Column
    private String completeBasename;

    @Column
    private int proteomeSize;

    @Column
    private Double algPredThreshold;

    @Column
    @Enumerated(EnumType.STRING)
    private PredictionModelType algPredictionModelType;

    @Column
    @Enumerated(EnumType.STRING)
    private DisplayMode algPredDisplayMode;

    /**
     * Type of analysis to perform (PREDICT, ANALYZE, or PREDICT_AND_ANALYZE)
     */
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private ActionType action;

    @Column
    private Integer blastMinIdentityCutoff;

    @Column
    private Integer blastMinCoverCutoff;

    @Column
    private Integer blastWordSize;

    @Transient
    private boolean doBlast;

    @Transient
    private List<Database> proteomes;

    /**
     * Threshold for epitope prediction using the BEPIPRED algorithm
     * This is a floating-point value that indicates the minimum score for an
     * epitope to be considered valid
     */
    @Column
    private Double bepipredThreshold;

    /**
     * Minimum allowed length for predicted epitopes (in amino acids)
     */
    @Column
    private Integer minEpitopeLength;

    /**
     * Maximum allowed length for predicted epitopes (in amino acids)
     */
    @Column
    private Integer maxEpitopeLength;

}